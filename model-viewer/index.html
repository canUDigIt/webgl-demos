<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Model Viewer</title>

    <!-- JQUERY Libs //-->
    <script src="js/lib/jquery.min.js"></script>

    <!-- WEBGL Libs //-->
    <script src="js/lib/twgl-full.js"></script>

    <! -- Shaders //-->
    <script id="vs" type="x-shader/x-vertex">
        precision mediump float;

        attribute vec4 position;
        attribute vec4 normal;

        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;
        uniform mat4 uNMatrix;

        varying vec4 eyePosition;
        varying vec4 eyeNormal;

        void main() 
        {
           gl_Position = uPMatrix * uMVMatrix * position;

           eyePosition = uMVMatrix * position;
           eyeNormal = uNMatrix * normal;
        }
    </script>

    <script id="fs" type="x-shader/x-fragment">
        precision mediump float;

        varying vec4 eyePosition;
        varying vec4 eyeNormal;

        uniform vec3 uLightPosition;
        uniform mat4 uMVMatrix;

        vec4 color = vec4(1.0, 0.0, 0.0, 1.0);
        float k0 = 1.0;
        float k1 = 0.0;
        float k2 = 0.0;

        void main()
        {
            vec4 eyeLightPosition = uMVMatrix * vec4(uLightPosition, 1.0);
            vec4 L = eyeLightPosition - eyePosition;
            float d = length(L);
            L = normalize(L);
            float diffuse = max(0.0, dot(eyeNormal, L));
            float attenuation = 1.0 / (k0 + (k1*d) + (k2*d*d));
            diffuse *= attenuation;

            gl_FragColor = diffuse * color;
        }
    </script>

    <script>
        $(document).ready(function() {
            var gl = document.getElementById("c").getContext("webgl");
            var programInfo = twgl.createProgramInfo(gl, ["vs", "fs"]);
            var m4 = twgl.m4;
            var v3 = twgl.v3;
            var fovRadians = Math.PI / 4;
            var aspectRatio = gl.canvas.width / gl.canvas.height;
            var near = 0.1;
            var far = 100.0;
            var perspective = m4.perspective(fovRadians, aspectRatio, near, far);
            var camera = m4.identity();
            var worldUp = v3.create(0, 1, 0);
            var target = v3.create(0, 0, 0);
            var distance = 5;
            var yaw = 0;
            var pitch = 0;
            var roll = 0;

            var myRequest = new Request('box.json');

            gl.enable(gl.DEPTH_TEST);

            fetch(myRequest)
                .then(function(response) { return response.json(); })
                .then(function(data) {
                    var mesh = data.meshes[0];
                    var arrays = {
                        position: mesh.vertices,
                        normal: mesh.normals,
                        indices: []
                    };
                    
                    mesh.faces.forEach(function(face) {
                        arrays.indices.push(face[0]);
                        arrays.indices.push(face[1]);
                        arrays.indices.push(face[2]);
                    });

                    var bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);

                    function yawPitchRoll() {
                        var rotation = m4.identity();
                         m4.rotateY(rotation, yaw, rotation);
                         m4.rotateX(rotation, pitch, rotation); 
                         m4.rotateZ(rotation, roll, rotation);
                         return rotation;
                    }

                    function render(time) {
                        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
                        gl.clearColor(0, 0, 0, 1);
                        gl.clear(gl.COLOR_BUFFER_BIT);
                        
                        var R = yawPitchRoll();
                        var T = m4.transformPoint(R, v3.create(0, 0, distance));
                        var position = v3.add(target, T);

                        var look = v3.create();
                        v3.subtract(target, position, look);
                        v3.normalize(look, look);

                        var right = v3.create();
                        v3.cross(look, worldUp, right);

                        var up = v3.create();
                        v3.cross(right, look, up);

                        var view = m4.create();
                        m4.lookAt(position, target, worldUp, view);

                        var uniforms = {
                            uMVMatrix: m4.inverse(view),
                            uPMatrix: perspective,
                            uNMatrix: m4.transpose(view),
                            uLightPosition: v3.add(position, v3.create(0, 5, 0))
                        };

                        gl.useProgram(programInfo.program);
                        twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);
                        twgl.setUniforms(programInfo, uniforms);
                        twgl.drawBufferInfo(gl, bufferInfo);

                        requestAnimationFrame(render);
                    }

                    requestAnimationFrame(render);
                });

            var dragging = false;
            var startX, startY;
            $(gl.canvas).mousedown(function(event) {
                event.preventDefault();
                startX = event.pageX;
                startY = event.pageY;
                dragging = true;
            });

            $(gl.canvas).mouseup(function(event) {
                event.preventDefault();
                dragging = false;
            });

            $(gl.canvas).mousemove(function(event) {
                event.preventDefault();
                if (dragging) {
                    deltaX = event.pageX - startX;
                    deltaY = event.pageY - startY;
                    startX = event.pageX;
                    startY = event.pageY;
                    var xWeight = 2 * Math.PI / gl.canvas.width;
                    var yWeight = (Math.PI / 4) / gl.canvas.height;
                    pitch += deltaY * yWeight;
                    yaw += deltaX * xWeight;
                }

                function clamp(min, x, max) {
                    return Math.min(Math.max(min, x), max);
                }

                $(gl.canvas).on("wheel", function(event){
                    event.preventDefault();
                    distance = clamp(2, distance - event.originalEvent.deltaY * 0.005, 25);
                    
                });
            });
        });
    </script>
</head>
<body>
    <canvas id="c" width="400" height="400">
        Please use a browser supporting "canvas"
    </canvas>

    <script type="text/javascript">

        
    </script>
</body>
</html>
