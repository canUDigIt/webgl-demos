<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Model Viewer</title>

    <!-- JQUERY Libs //-->
    <script src="js/lib/jquery.min.js"></script>

    <!-- WEBGL Libs //-->
    <script src="js/lib/twgl-full.js"></script>

    <! -- Shaders //-->
    <script id="vs" type="x-shader/x-vertex">
        precision mediump float;

        attribute vec4 position;
        attribute vec4 normal;

        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;
        uniform mat4 uNMatrix;

        varying vec4 eyePosition;
        varying vec4 eyeNormal;

        void main() 
        {
           gl_Position = uPMatrix * uMVMatrix * position;

           eyePosition = uMVMatrix * position;
           eyeNormal = uNMatrix * normal;
        }
    </script>

    <script id="fs" type="x-shader/x-fragment">
        precision mediump float;

        varying vec4 eyePosition;
        varying vec4 eyeNormal;

        uniform vec3 uLightDirection;
        uniform mat4 uMVMatrix;

        vec4 color = vec4(1.0, 0.0, 0.0, 1.0);
        vec4 ambient = vec4(0.2, 0.2, 0.2, 1.0);
        vec4 lightColor = vec4(1.0, 1.0, 1.0, 1.0);
        float specularStrength = 0.5;

        void main()
        {
            vec4 eyeLightDirection = uMVMatrix * vec4(uLightDirection, 0.0);
            vec4 L = normalize(eyeLightDirection);

            vec4 norm = normalize(eyeNormal);

            float cosTheta = max(0.0, dot(norm, L));
            vec4 diffuse = cosTheta * lightColor;

            gl_FragColor = (diffuse + ambient) * color;
        }
    </script>

    <script>
        $(document).ready(function() {
            var gl = document.getElementById("c").getContext("webgl");
            var programInfo = twgl.createProgramInfo(gl, ["vs", "fs"]);
            var m4 = twgl.m4;
            var v3 = twgl.v3;

            var fovRadians = Math.PI / 4;
            var aspectRatio = gl.canvas.width / gl.canvas.height;
            var near = 0.1;
            var far = 100.0;
            var perspective = m4.perspective(fovRadians, aspectRatio, near, far);
            var camera = m4.identity();
            var worldUp = v3.create(0, 1, 0);
            var target = v3.create(0, 0, 0);
            var distance = 5;
            var minDistance = 2;
            var maxDistance = 25;
            var minPitch = -89 * (Math.PI / 180);
            var maxPitch = 89 * (Math.PI / 180);
            var yaw = 0;
            var pitch = 0;
            var roll = 0;
            var rotationSpeed = 1 / 100;
            var zoomSpeed = 1 / 250;

            var myRequest = new Request('box.json');

            gl.enable(gl.DEPTH_TEST);

            fetch(myRequest)
                .then(function(response) { return response.json(); })
                .then(function(data) {
                    var mesh = data.meshes[0];
                    var arrays = {
                        position: mesh.vertices,
                        normal: mesh.normals,
                        indices: []
                    };
                    
                    mesh.faces.forEach(function(face) {
                        arrays.indices.push(face[0]);
                        arrays.indices.push(face[1]);
                        arrays.indices.push(face[2]);
                    });

                    var bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);

                    function yawPitchRoll() {
                        var rotation = m4.identity();
                         m4.rotateY(rotation, yaw, rotation);
                         m4.rotateX(rotation, pitch, rotation); 
                         m4.rotateZ(rotation, roll, rotation);
                         return rotation;
                    }

                    function render(time) {
                        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
                        gl.clearColor(0, 0, 0, 1);
                        gl.clear(gl.COLOR_BUFFER_BIT);
                        
                        var R = yawPitchRoll();
                        var T = m4.transformPoint(R, v3.create(0, 0, distance));
                        var position = v3.add(target, T);

                        var look = v3.create();
                        v3.subtract(target, position, look);
                        v3.normalize(look, look);

                        var right = v3.create();
                        v3.cross(look, worldUp, right);

                        var up = v3.create();
                        v3.cross(right, look, up);

                        var view = m4.create();
                        m4.lookAt(position, target, worldUp, view);

                        var uniforms = {
                            uMVMatrix: m4.inverse(view),
                            uPMatrix: perspective,
                            uNMatrix: m4.transpose(view),
                            uLightDirection: v3.subtract(v3.add(position, v3.create(0, 5, 0)), target)
                        };

                        gl.useProgram(programInfo.program);
                        twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);
                        twgl.setUniforms(programInfo, uniforms);
                        twgl.drawBufferInfo(gl, bufferInfo);

                        requestAnimationFrame(render);
                    }

                    requestAnimationFrame(render);
                });

            var dragging = false;
            var startX, startY;
            gl.canvas.addEventListener("mousedown", function(event) {
                event.preventDefault();
                startX = event.pageX;
                startY = event.pageY;
                dragging = true;
            });

            gl.canvas.addEventListener("mouseup", function(event) {
                event.preventDefault();
                dragging = false;
            });

            gl.canvas.addEventListener("mouseout", function(event) {
                event.preventDefault();
                dragging = false;
            });

            gl.canvas.addEventListener("mousemove", function(event) {
                event.preventDefault();
                if (dragging) {
                    deltaX = event.pageX - startX;
                    deltaY = event.pageY - startY;
                    startX = event.pageX;
                    startY = event.pageY;
                    pitch = clamp(minPitch, pitch - deltaY * rotationSpeed, maxPitch);
                    yaw -= deltaX * rotationSpeed;
                }
            });

            gl.canvas.addEventListener("wheel", function(event){
                var delta = event.deltaY * zoomSpeed;
                distance = clamp(minDistance, distance - delta, maxDistance);
                event.preventDefault();
            });

            function clamp(min, x, max) {
                return Math.min(Math.max(min, x), max);
            }
        });
    </script>
</head>
<body>
    <canvas id="c" width="400" height="400">
        Please use a browser supporting "canvas"
    </canvas>

    <script type="text/javascript">

        
    </script>
</body>
</html>
