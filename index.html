<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL experimentation</title>

    <!-- JQUERY Libs //-->
    <script src="//code.jquery.com/jquery-1.10.2.min.js"></script>
    <!-- MATH Libs //-->
    <script src="js/math/gl-matrix.js"></script>
    <!-- WEBGL Libs //-->
    <script src="https://rawgithub.com/mrdoob/three.js/master/build/three.js"></script>
    <script src="js/webgl/Utils.js"></script>

    <script id="shader-vs" type="x-shader/x-vertex">
        attribute vec4 a_Position;

        uniform mat4 u_MVMatrix;
        uniform mat4 u_PMatrix;

        void main() {
           gl_Position = u_PMatrix * u_MVMatrix * a_Position;
           gl_PointSize = 10.0;
        }
    </script>

    <script id="shader-fs" type="x-shader/x-fragment">
        precision mediump float;

        uniform vec4 u_FragColor;

        void main() {
           gl_FragColor = u_FragColor;
        }
    </script>

    <script id="code-js" type="text/javascript">

        function runThreeJsApp() {
            configure();
            load();
            render();
        }

        (function(global) {

            var canvas, 
                c_width, 
                c_height, 
                halfWidth, 
                halfHeight,

                scene,
                camera,

                renderer,

                head, 
                body, 
                leftLeg, 
                rightLeg, 
                leftShoulder, 
                rightShoulder, 
                leftArm, 
                rightArm,

                // milliseconds
                animationRate = 15,
                initialTime = (new Date()).getTime(),
                elapsedTime,
                sceneTime = 0.0,

                g_leftMouseButton,
                g_middleMouseButton,
                g_rightMouseButton,
                dragStartPos;

            global.configure = function() {
                canvas = document.getElementById("canvas-id");
                c_width = canvas.width;
                c_height = canvas.height;

                halfWidth = c_width / 2;
                halfHeight = c_height / 2;

                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera( 45, c_width/c_height, 1, 1000);

                renderer =  new THREE.WebGLRenderer( { canvas: canvas } );
                renderer.setSize(c_width, c_height);

                g_leftMouseButton = false;
                g_middleMouseButton = false;
                g_rightMouseButton = false;
                dragStartPos = new THREE.Vector2();
            };

            global.load = function() {

                var headRadius = 5,
                    headGeometry = new THREE.SphereGeometry( headRadius, 32, 32 ),
                    headMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000 } ),

                    bodyRadius = 10,
                    bodyHeight = 25,
                    bodyGeometry = new THREE.CylinderGeometry( bodyRadius, bodyRadius, bodyHeight ),
                    bodyMaterial = new THREE.MeshBasicMaterial( { color: 0x00ff00 } ),

                    legRadius = 3,
                    legHeight = 25,
                    legGeometry = new THREE.CylinderGeometry( legRadius, legRadius, legHeight ),
                    legMaterial = new THREE.MeshBasicMaterial( { color: 0xffff00 } ),

                    armRadius = 3,
                    armHeight = 30,
                    armGeometry = new THREE.CylinderGeometry( armRadius, armRadius, armHeight ),
                    armMaterial = new THREE.MeshBasicMaterial( { color: 0x00ffff } ),

                    translationMat = new THREE.Matrix4();

                head = new THREE.Mesh( headGeometry, headMaterial );
                body = new THREE.Mesh( bodyGeometry, bodyMaterial );
                leftLeg = new THREE.Mesh( legGeometry, legMaterial );
                rightLeg = new THREE.Mesh( legGeometry, legMaterial );
                leftArm = new THREE.Mesh( armGeometry, armMaterial );
                rightArm = new THREE.Mesh( armGeometry, armMaterial );
                leftShoulder = new THREE.Object3D();
                rightShoulder = new THREE.Object3D();

                body.add(head);
                body.add(leftLeg);
                body.add(rightLeg);
                body.add(leftShoulder);
                body.add(rightShoulder);

                leftShoulder.add(leftArm);
                rightShoulder.add(rightArm);

                translationMat.makeTranslation( 0, (bodyHeight / 2) + headRadius, 0 );
                head.applyMatrix( translationMat );

                translationMat.makeTranslation( -bodyRadius + legRadius, (-bodyHeight / 2) - (legHeight / 2), 0 );
                leftLeg.applyMatrix( translationMat );

                translationMat.makeTranslation( bodyRadius - legRadius, (-bodyHeight / 2) - (legHeight / 2), 0 );
                rightLeg.applyMatrix( translationMat );

                translationMat.makeTranslation( 0, -armHeight/2, 0 );
                leftArm.applyMatrix( translationMat );
                rightArm.applyMatrix( translationMat );

                translationMat.makeTranslation( -bodyRadius, bodyHeight/2, 0 );
                leftShoulder.applyMatrix( translationMat );

                translationMat.makeTranslation( bodyRadius, bodyHeight/2, 0 );
                rightShoulder.applyMatrix( translationMat );

                scene.add(body);

                camera.position.setZ(120);
            };

            global.render = function() {
                var steps = Math.floor( elapsedTime / animationRate );

                Utils.requestAnimFrame(render);

                elapsedTime = ( (new Date()).getTime() - initialTime );
                if (elapsedTime < animationRate) return;

                while(steps > 0) {
                    animate();
                    renderer.render(scene, camera);
                    steps -= 1;
                }

                initialTime = (new Date()).getTime();
            };

            function animate() {

                sceneTime += 33/1000;
            }

            function transformOWithRespectToA(transform, O, A) {
                var inverseA = new THREE.Matrix4(),
                    resultingMatrix = new THREE.Matrix4();

                inverseA.getInverse(A);
                resultingMatrix.multiply(O).multiply(inverseA).multiply(transform).multiply(A);

                return resultingMatrix;
            }

            function handleMouseDown(event) {
                switch(event.which)
                {
                    case 1:
                        g_leftMouseButton = true;
                        break;
                    case 2:
                        g_middleMouseButton = true;
                        break;
                    case 3:
                        g_rightMouseButton = true;
                        break;
                    default:
                        break;
                }

                dragStartPos.set(event.pageX, event.pageY);
            }

            function handleMouseUp(event) {
                switch(event.which)
                {
                    case 1:
                        g_leftMouseButton = false;
                        break;
                    case 2:
                        g_middleMouseButton = false;
                        break;
                    case 3:
                        g_rightMouseButton = false;
                        break;
                    default:
                        break;
                }
            }

            function handleMouseMove(event) {

                if (g_leftMouseButton || g_middleMouseButton || g_rightMouseButton) {
                    var currentPos = new THREE.Vector2(event.pageX, event.pageY),
                        distance = dragStartPos.distanceTo(currentPos),
                        angle = distance % 360,
                        rotationMatrix = new THREE.Matrix4();

                    if (g_leftMouseButton) {
                        rotationMatrix.makeRotationX(angle);
                    }

                    if (g_rightMouseButton) {
                        rotationMatrix.makeRotationY(angle);
                    }

                    var objectRotationFrame = new THREE.Matrix4();
                    objectRotationFrame.copyPosition( body.matrix );
                    objectRotationFrame.extractRotation( camera.matrix );

                    body.applyMatrix( transformOWithRespectToA(rotationMatrix, body.matrix, objectRotationFrame) );
                }

            }

            $("#canvas-id").mousedown( handleMouseDown );
            $("#canvas-id").mouseup( handleMouseUp );
            $("#canvas-id").mousemove( handleMouseMove );
            
        }(this));

    </script>
</head>
<body onload="runThreeJsApp()">
    <canvas id="canvas-id" width="400" height="400">
        Please use a browser supporting "canvas"
    </canvas>

    <script type="text/javascript">

        
    </script>
</body>
</html>