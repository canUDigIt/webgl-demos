<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL experimentation</title>

    <!-- JQUERY Libs //-->
    <script src="//code.jquery.com/jquery-1.10.2.min.js"></script>
    <!-- MATH Libs //-->
    <script src="js/math/gl-matrix.js"></script>
    <!-- WEBGL Libs //-->
    <script src="https://rawgithub.com/mrdoob/three.js/master/build/three.js"></script>
    <script src="js/webgl/Globals.js"></script>
    <script src="js/webgl/Utils.js"></script>
    <script src="js/webgl/ThreejsApp.js"></script>

    <script id="shader-vs" type="x-shader/x-vertex">
        attribute vec4 a_Position;

        uniform mat4 u_MVMatrix;
        uniform mat4 u_PMatrix;

        void main() {
           gl_Position = u_PMatrix * u_MVMatrix * a_Position;
           gl_PointSize = 10.0;
        }
    </script>

    <script id="shader-fs" type="x-shader/x-fragment">
        precision mediump float;

        uniform vec4 u_FragColor;

        void main() {
           gl_FragColor = u_FragColor;
        }
    </script>

    <script id="code-js" type="text/javascript">

        (function() {

            $( document ).ready( function() {
                runThreeJsApp();
            });

            function runThreeJsApp() {
                var canvas = document.getElementById("canvas-id"),
                    app = new ThreejsApp( { canvas : canvas } );

                c_width = canvas.width;
                c_height = canvas.height;

                app.configureHook = configure;
                app.loadSceneHook = load;
                app.drawSceneHook = render;

                $( "#canvas-id" )
                    .mousedown( handleMouseDown )
                    .mouseup( handleMouseUp )
                    .mousemove( handleMouseMove );

                app.run();
            }

            Math.radians = function(degrees) {
                return degrees * Math.PI / 180;
            };

            Math.degrees = function(radians) {
                return radians * 180 / Math.PI;
            };

            var halfWidth, 
                halfHeight,

                scene,
                camera,

                head, 
                body, 
                leftLeg, 
                rightLeg, 
                leftShoulder, 
                rightShoulder, 
                leftArm, 
                rightArm,

                // milliseconds
                animationRate = 15,
                initialTime = (new Date()).getTime(),
                elapsedTime,
                sceneTime = 0.0,

                g_leftMouseButton,
                g_middleMouseButton,
                g_rightMouseButton,
                g_lastPosition;

            function configure() {
                halfWidth = c_width / 2;
                halfHeight = c_height / 2;

                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera( 45, c_width/c_height, 1, 1000);

                renderer.setSize(c_width, c_height);

                g_leftMouseButton = false;
                g_middleMouseButton = false;
                g_rightMouseButton = false;
                g_lastPosition = new THREE.Vector2();
            }

            function load() {
                var headRadius = 5,
                    headGeometry = new THREE.SphereGeometry( headRadius, 32, 32 ),
                    headMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000 } ),

                    bodyRadius = 10,
                    bodyHeight = 25,
                    bodyGeometry = new THREE.CylinderGeometry( bodyRadius, bodyRadius, bodyHeight ),
                    bodyMaterial = new THREE.MeshBasicMaterial( { color: 0x00ff00 } ),

                    legRadius = 3,
                    legHeight = 25,
                    legGeometry = new THREE.CylinderGeometry( legRadius, legRadius, legHeight ),
                    legMaterial = new THREE.MeshBasicMaterial( { color: 0xffff00 } ),

                    armRadius = 3,
                    armHeight = 30,
                    armGeometry = new THREE.CylinderGeometry( armRadius, armRadius, armHeight ),
                    armMaterial = new THREE.MeshBasicMaterial( { color: 0x00ffff } ),

                    translationMat = new THREE.Matrix4();

                head = new THREE.Mesh( headGeometry, headMaterial );
                body = new THREE.Mesh( bodyGeometry, bodyMaterial );
                leftLeg = new THREE.Mesh( legGeometry, legMaterial );
                rightLeg = new THREE.Mesh( legGeometry, legMaterial );
                leftArm = new THREE.Mesh( armGeometry, armMaterial );
                rightArm = new THREE.Mesh( armGeometry, armMaterial );
                leftShoulder = new THREE.Object3D();
                rightShoulder = new THREE.Object3D();

                body.add(head);
                body.add(leftLeg);
                body.add(rightLeg);
                body.add(leftShoulder);
                body.add(rightShoulder);

                leftShoulder.add(leftArm);
                rightShoulder.add(rightArm);

                translationMat.makeTranslation( 0, (bodyHeight / 2) + headRadius, 0 );
                head.applyMatrix( translationMat );

                translationMat.makeTranslation( -bodyRadius + legRadius, (-bodyHeight / 2) - (legHeight / 2), 0 );
                leftLeg.applyMatrix( translationMat );

                translationMat.makeTranslation( bodyRadius - legRadius, (-bodyHeight / 2) - (legHeight / 2), 0 );
                rightLeg.applyMatrix( translationMat );

                translationMat.makeTranslation( 0, -armHeight/2, 0 );
                leftArm.applyMatrix( translationMat );
                rightArm.applyMatrix( translationMat );

                translationMat.makeTranslation( -bodyRadius, bodyHeight/2, 0 );
                leftShoulder.applyMatrix( translationMat );

                translationMat.makeTranslation( bodyRadius, bodyHeight/2, 0 );
                rightShoulder.applyMatrix( translationMat );

                scene.add(body);

                camera.position.setZ(120);
            }

            function render() {
                var steps = Math.floor( elapsedTime / animationRate );

                elapsedTime = ( (new Date()).getTime() - initialTime );
                if (elapsedTime < animationRate) {
                    return;
                }

                while(steps > 0) {
                    animate();
                    renderer.render(scene, camera);
                    steps -= 1;
                }

                initialTime = (new Date()).getTime();
            }

            function animate() {
                sceneTime += 33/1000;
            }

            function transformWithRespectToA(transform, A) {
                var resultingMatrix = new THREE.Matrix4();

                resultingMatrix.getInverse(A).multiply(transform).multiply(A);

                return resultingMatrix;
            }

            function handleMouseDown(event) {
                switch(event.which)
                {
                    case 1:
                        g_leftMouseButton = true;
                        break;
                    case 2:
                        g_middleMouseButton = true;
                        break;
                    case 3:
                        g_rightMouseButton = true;
                        break;
                    default:
                        break;
                }
            }

            function handleMouseUp(event) {
                switch(event.which)
                {
                    case 1:
                        g_leftMouseButton = false;
                        break;
                    case 2:
                        g_middleMouseButton = false;
                        break;
                    case 3:
                        g_rightMouseButton = false;
                        break;
                    default:
                        break;
                }
            }

            function handleMouseMove(event) {
                var currentPosition = new THREE.Vector2(event.pageX, event.pageY);

                if (g_leftMouseButton || g_middleMouseButton || g_rightMouseButton) {
                    var diffPos = new THREE.Vector2();
                        rotationMatrix = new THREE.Matrix4();

                    diffPos.subVectors( currentPosition, g_lastPosition );

                    if (g_leftMouseButton) {
                        if ( Math.abs(diffPos.x) > Math.abs(diffPos.y) ) {
                            rotationMatrix.makeRotationY( Math.radians( diffPos.x ) );
                        } 
                        else {
                            rotationMatrix.makeRotationX( Math.radians( diffPos.y ) );
                        }
                    }

                    if (g_rightMouseButton) {
                        
                    }

                    var objectRotationFrame = new THREE.Matrix4(),
                        correctedRotationMatrix = new THREE.Matrix4();

                    objectRotationFrame.copyPosition( body.matrix );
                    objectRotationFrame.extractRotation( camera.matrix );

                    body.applyMatrix( transformWithRespectToA( rotationMatrix, objectRotationFrame ) );
                }

                g_lastPosition = currentPosition;
            }
            
        }());

    </script>
</head>
<body>
    <canvas id="canvas-id" width="400" height="400">
        Please use a browser supporting "canvas"
    </canvas>

    <script type="text/javascript">

        
    </script>
</body>
</html>